# Container Orchestrator Experimentation Platform - PRD

## Executive Summary

A lightweight Flask-based web application for experimenting with container orchestration techniques using Docker. The platform provides a simple UI to spawn, control, and monitor Docker containers through Python automation libraries like `pexpect` and `dockerpty`, with hot-reload capabilities for rapid development iteration.

## Product Overview

### Purpose
Enable rapid experimentation and learning of container orchestration patterns through a simple, modifiable web interface that demonstrates various container control techniques.

## Educational Focus

### Learning Objectives
This platform is specifically designed for **students and beginners** to learn container orchestration concepts through hands-on experimentation. The codebase emphasizes:

- **Clarity Over Cleverness**: Simple, readable code with extensive comments
- **Progressive Complexity**: Examples start basic and build up to advanced concepts
- **Real-World Patterns**: Demonstrates actual orchestration techniques used in production
- **Immediate Feedback**: Visual results for every action to reinforce learning

### Student-Friendly Features
- **One-Command Setup**: `make setup` gets everything running
- **Rich Documentation**: Every function and example is thoroughly documented
- **Error Education**: Clear error messages that teach rather than just report
- **Modification Encouragement**: Code structure that invites experimentation

## Technical Requirements

### Core Architecture

#### Container Setup
- **Base Image**: `python:slim`
- **Volume Mounts**:
  - `/var/run/docker.sock:/var/run/docker.sock` (Docker daemon access)
  - `./src:/app/src` (Source code directory for hot-reload)
- **Working Directory**: `/app`
- **Port Exposure**: 5000 (Flask development server)

#### Dependency Management
- **Package Manager**: `uv` (fast Python package installer and resolver)
- **Dependencies**:
  ```
  flask>=2.3.0
  docker>=6.1.0
  pexpect>=4.8.0
  dockerpty>=0.4.1
  watchdog>=3.0.0
  python-dotenv>=1.0.0
  ```

### Application Structure

```
project/
├── Dockerfile
├── docker-compose.yml
├── Makefile                  # Common development tasks
├── pyproject.toml           # uv configuration
├── requirements.txt         # Generated by uv for Docker
├── .env.example            # Sample environment configuration
├── .gitignore              # Python and Docker ignores
├── README.md               # Setup and usage instructions
├── src/
│   ├── app.py                 # Main Flask application
│   ├── orchestrator/
│   │   ├── __init__.py
│   │   ├── core.py           # Core orchestration functions
│   │   ├── examples.py       # Example flows and patterns
│   │   └── utils.py          # Utility functions
│   ├── templates/
│   │   ├── base.html         # Base template
│   │   ├── index.html        # Main dashboard
│   │   ├── containers.html   # Container management view
│   │   └── logs.html         # Log viewing interface
│   └── static/
│       ├── css/
│       │   └── style.css     # Simple, clean styling
│       └── js/
│           └── app.js        # Basic interactivity
```

## Functional Requirements

### Core Features

#### 1. Container Management Interface
- **Dashboard View**: Display running containers with status indicators
- **Spawn Controls**: Buttons/forms to launch predefined container configurations
- **Container List**: Real-time view of active containers with basic info (name, image, status, uptime)
- **Quick Actions**: Start, stop, restart, and remove containers

#### 2. Example Orchestration Flows

*Note: Each example includes detailed comments, error handling, and educational explanations suitable for students learning these concepts.*

##### Flow 1: Container Basics - "Hello World"
```python
def hello_world_container():
    """
    LEARNING GOAL: Understand basic container lifecycle
    
    This example demonstrates:
    - Creating a container from an image
    - Running a simple command
    - Capturing output
    - Proper cleanup
    """
    # Step-by-step implementation with educational comments
```

##### Flow 2: Interactive Shell Session
```python
def interactive_shell_example():
    """
    LEARNING GOAL: Real-time container interaction
    
    Demonstrates dockerpty for interactive sessions:
    - Attaching to container stdin/stdout
    - Handling user input/output
    - Managing session lifecycle
    """
    # Implementation with pexpect and dockerpty
```

##### Flow 3: Command Automation with pexpect
```python
def automated_commands_example():
    """
    LEARNING GOAL: Automate complex command sequences
    
    Shows how to:
    - Send commands to containers
    - Wait for specific output patterns
    - Parse command results
    - Handle command failures
    """
    # pexpect patterns for container automation
```

##### Flow 4: Multi-Container Dependencies
```python
def dependency_orchestration():
    """
    LEARNING GOAL: Container coordination patterns
    
    Demonstrates:
    - Starting containers in correct order
    - Health checks and readiness probes
    - Inter-container communication
    - Graceful shutdown sequences
    """
    # Multi-container coordination logic
```

##### Flow 5: Log Monitoring and Event Response
```python
def log_monitoring_example():
    """
    LEARNING GOAL: Event-driven container management
    
    Teaches:
    - Real-time log streaming
    - Pattern matching in logs
    - Automated responses to events
    - Log aggregation techniques
    """
    # Log monitoring and parsing implementation
```

##### Flow 6: Health Monitoring and Recovery
```python
def health_check_recovery():
    """
    LEARNING GOAL: Production-ready reliability patterns
    
    Covers:
    - Defining custom health checks
    - Implementing restart policies
    - Cascading failure handling
    - Monitoring container resources
    """
    # Health check and recovery automation
```

##### Flow 7: Container Networking Experiments
```python
def networking_examples():
    """
    LEARNING GOAL: Container networking concepts
    
    Explores:
    - Creating custom networks
    - Container-to-container communication
    - Port mapping strategies
    - Network isolation patterns
    """
    # Networking configuration and testing
```

##### Flow 8: Volume and Data Management
```python
def volume_management_example():
    """
    LEARNING GOAL: Persistent data patterns
    
    Demonstrates:
    - Creating and mounting volumes
    - Data persistence strategies
    - Backup and restore procedures
    - Sharing data between containers
    """
    # Volume management patterns
```

#### 3. Development Features
- **Auto-reload**: Automatic Flask restart when Python files change
- **Live Logs**: Real-time log streaming in the web interface
- **Code Editor Integration**: Simple text areas for quick code modifications
- **Error Handling**: Clear error messages and debugging information

### User Interface Requirements

#### Design Principles
- **Minimalist**: Clean, uncluttered interface focused on functionality
- **Responsive**: Works on desktop and tablet devices
- **Fast**: Quick loading and real-time updates
- **Accessible**: Clear navigation and readable typography

#### Page Layout

##### Main Dashboard
- Container status grid (3-4 columns)
- Quick action buttons for example flows
- System resource overview (optional)
- Recent activity log

##### Container Management
- Detailed container list with sortable columns
- Individual container controls
- Log viewing panel
- Resource usage metrics

##### Example Flows
- Categorized list of example functions
- One-click execution buttons
- Parameter input forms for customizable examples
- Output display areas

## Technical Specifications

### Environment Configuration

#### pyproject.toml (uv configuration)
```toml
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "containerpoker"
version = "0.1.0"
description = "Container orchestration learning platform"
dependencies = [
    "flask>=2.3.0",
    "docker>=6.1.0",
    "pexpect>=4.8.0",
    "dockerpty>=0.4.1",
    "watchdog>=3.0.0",
    "python-dotenv>=1.0.0",
]

[tool.uv]
dev-dependencies = [
    "pytest>=7.0.0",
    "black>=23.0.0",
    "flake8>=6.0.0",
]
```

#### Makefile
```makefile
.PHONY: help setup install clean start stop restart logs shell test format lint

# Default target
help:
	@echo "Container Poker - Container Orchestration Learning Platform"
	@echo ""
	@echo "Available commands:"
	@echo "  setup     - Complete project setup (install uv, deps, build, start)"
	@echo "  install   - Install dependencies with uv"
	@echo "  build     - Build Docker containers"
	@echo "  start     - Start the application"
	@echo "  stop      - Stop all containers"
	@echo "  restart   - Restart the application"
	@echo "  logs      - Show application logs"
	@echo "  shell     - Open shell in the orchestrator container"
	@echo "  clean     - Clean up containers and images"
	@echo "  test      - Run tests"
	@echo "  format    - Format code with black"
	@echo "  lint      - Lint code with flake8"
	@echo "  git-init  - Initialize git repo and push to GitHub"

# Complete setup for new students
setup: check-uv install build start
	@echo "🎉 Setup complete! Visit http://localhost:5000"
	@echo "📚 Check README.md for usage instructions"

# Check if uv is installed
check-uv:
	@which uv > /dev/null || (echo "❌ uv not found. Install with: curl -LsSf https://astral.sh/uv/install.sh | sh" && exit 1)
	@echo "✅ uv found"

# Install Python dependencies
install:
	@echo "📦 Installing dependencies..."
	uv sync
	uv export --no-hashes > requirements.txt

# Build Docker containers
build:
	@echo "🔨 Building containers..."
	docker-compose build

# Start the application
start:
	@echo "🚀 Starting Container Poker..."
	docker-compose up -d
	@echo "🌐 Application available at http://localhost:5000"

# Stop containers
stop:
	@echo "🛑 Stopping containers..."
	docker-compose down

# Restart the application
restart: stop start

# Show logs
logs:
	docker-compose logs -f

# Open shell in orchestrator container
shell:
	docker-compose exec orchestrator bash

# Clean up everything
clean:
	@echo "🧹 Cleaning up..."
	docker-compose down -v --remove-orphans
	docker system prune -f

# Run tests
test:
	uv run pytest

# Format code
format:
	uv run black src/

# Lint code  
lint:
	uv run flake8 src/

# Initialize git repository and push to GitHub
git-init:
	@echo "🔧 Initializing git repository..."
	git init
	cp .env.example .env
	git add .
	git commit -m "Initial commit: Container Poker learning platform"
	@echo "📡 Creating GitHub repository 'containerpoker'..."
	gh repo create containerpoker --public --description "Container orchestration learning platform for students"
	git branch -M main
	git remote add origin https://github.com/$(gh api user --jq .login)/containerpoker.git
	git push -u origin main
	@echo "🎉 Repository created and pushed to GitHub!"
	@echo "🔗 Visit: https://github.com/$(gh api user --jq .login)/containerpoker"
```

#### .gitignore
```gitignore
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Virtual environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/
.python-version

# IDEs
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Docker
.dockerignore

# Logs
*.log
logs/

# uv
.uv/
uv.lock

# Flask
instance/
.webassets-cache

# Testing
.pytest_cache/
.coverage
htmlcov/

# Temporary files
*.tmp
*.temp
.cache/

# Local development
.env.local
local_settings.py
```

#### .env.example
```bash
# Flask Configuration
FLASK_ENV=development
FLASK_DEBUG=1
FLASK_HOST=0.0.0.0
FLASK_PORT=5000

# Docker Configuration
DOCKER_HOST=unix:///var/run/docker.sock

# Application Settings
APP_NAME=Container Poker
APP_VERSION=0.1.0

# Security (change in production)
SECRET_KEY=your-secret-key-here-change-in-production

# Container Defaults
DEFAULT_CONTAINER_IMAGE=ubuntu:latest
DEFAULT_CONTAINER_TIMEOUT=30

# Development Settings
AUTO_RELOAD=true
DEBUG_LOGS=true

# Example Container Images (for educational examples)
EXAMPLE_IMAGES=ubuntu:latest,python:slim,node:alpine,nginx:alpine

# Student Learning Settings
SHOW_DETAILED_ERRORS=true
ENABLE_CODE_EXAMPLES=true
TUTORIAL_MODE=true

# GitHub Repository (auto-filled by setup)
GITHUB_REPO=containerpoker
```

#### Dockerfile
```dockerfile
FROM python:slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
    docker.io \
    git \
    curl \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Copy dependency files
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Set up volume mount point for source code
VOLUME ["/app/src"]

# Expose Flask port
EXPOSE 5000

# Set environment variables for development
ENV FLASK_ENV=development
ENV FLASK_DEBUG=1
ENV PYTHONUNBUFFERED=1

# Development server with auto-reload
CMD ["python", "src/app.py"]
```

#### Docker Compose
```yaml
version: '3.8'
services:
  orchestrator:
    build: .
    ports:
      - "5000:5000"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ./src:/app/src
    environment:
      - FLASK_ENV=development
      - FLASK_DEBUG=1
```

### API Endpoints

#### Core Routes
- `GET /` - Main dashboard
- `GET /containers` - Container management page
- `GET /examples` - Example flows page
- `POST /api/containers/spawn` - Spawn new container
- `POST /api/containers/{id}/action` - Container actions (start/stop/restart)
- `GET /api/containers/{id}/logs` - Stream container logs
- `POST /api/examples/{flow_name}` - Execute example flow
- `GET /api/status` - System status and health

### Example Implementation Patterns

#### Pexpect Integration
```python
import pexpect
import docker

def pexpect_container_control(image, command):
    """Use pexpect to control container interactively"""
    client = docker.from_env()
    container = client.containers.run(
        image, 
        command, 
        detach=True, 
        tty=True, 
        stdin_open=True
    )
    
    # Use pexpect to interact with container
    child = pexpect.spawn(f'docker exec -it {container.id} /bin/bash')
    child.expect('$')
    child.sendline('echo "Hello from container"')
    child.expect('$')
    output = child.before.decode()
    
    return container, output
```

#### Dockerpty Integration
```python
import dockerpty
import docker

def dockerpty_interactive_session(image):
    """Create interactive session using dockerpty"""
    client = docker.from_env()
    container = client.containers.create(
        image,
        '/bin/bash',
        tty=True,
        stdin_open=True
    )
    container.start()
    dockerpty.start(client.api, container.id)
```

## Development Guidelines

### Code Organization
- **Modular Design**: Separate concerns into distinct modules
- **Example Functions**: Each example flow in its own function with clear documentation
- **Error Handling**: Comprehensive try-catch blocks with user-friendly error messages
- **Logging**: Structured logging for debugging and monitoring

### Development Workflow

#### Quick Start for Students
1. **Initial Setup** (one-time):
   ```bash
   git clone https://github.com/username/containerpoker.git
   cd containerpoker
   make setup
   ```

2. **Daily Development**:
   ```bash
   make start    # Start the platform
   # Edit files in src/ - changes auto-reload
   make logs     # View real-time logs
   make shell    # Debug in container
   ```

3. **Experimentation Cycle**:
   - Modify Python files in `./src` directory
   - Flask auto-reload detects changes and restarts server
   - Test changes immediately in browser at http://localhost:5000
   - Iterate quickly on orchestration patterns

#### Project Initialization
After creating the project structure, run:
```bash
make git-init
```
This will:
- Initialize a git repository
- Create the `.env` file from template
- Commit initial code
- Create GitHub repository named "containerpoker"
- Push code to GitHub
- Display repository URL

### Testing Strategy
- **Manual Testing**: Primary method through web interface
- **Example Validation**: Each example flow should be self-contained and testable
- **Error Cases**: Test container failure scenarios and cleanup

## Security Considerations

### Container Security
- **Docker Socket Access**: Limited to orchestrator container only
- **Image Restrictions**: Use only trusted base images for spawned containers
- **Resource Limits**: Implement container resource constraints

### Application Security
- **Input Validation**: Sanitize all user inputs before container operations
- **Command Injection**: Prevent shell injection in container commands
- **Access Control**: Basic authentication for production use (optional)

## Success Metrics

### Success Metrics

#### Student Learning Outcomes
- **Setup Time**: < 2 minutes from clone to running (`make setup`)
- **First Success**: Students can run their first container within 5 minutes
- **Iteration Speed**: < 10 seconds from code change to testing
- **Learning Progression**: 8 example flows from basic to advanced
- **Understanding**: Clear examples enable comprehension within 30 minutes

#### Educational Effectiveness
- **Hands-On Learning**: Every concept demonstrated with working code
- **Progressive Difficulty**: Examples build from simple to complex
- **Real-World Relevance**: Patterns used in actual production systems
- **Modification Friendly**: Students encouraged to experiment and break things

### Functionality Validation
- **Container Operations**: All basic container lifecycle operations work
- **Example Flows**: All provided examples execute successfully
- **Error Recovery**: Graceful handling of container failures

## Future Enhancements

### Phase 2 Features
- **Container Templates**: Predefined container configurations
- **Workflow Builder**: Visual workflow creation interface
- **Monitoring Dashboard**: Enhanced metrics and alerting
- **Plugin System**: Extensible architecture for custom orchestration patterns

### Integration Possibilities
- **CI/CD Integration**: Webhook support for automated testing
- **Kubernetes Patterns**: Examples transitioning to K8s concepts
- **Service Mesh**: Istio/Linkerd integration examples

## Conclusion

This platform provides a solid foundation for experimenting with container orchestration techniques while maintaining simplicity and ease of modification. The focus on clear examples and rapid iteration makes it ideal for learning and prototyping orchestration patterns before implementing them in production environments.